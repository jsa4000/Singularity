####################################
####################################
##      GRAPH BASED EXAMPLE       ##
####################################
####################################

import numpy as np
import json
import uuid

# The idea is to declare pre-defined structures like parameters, nodes, etc to be used with different nodes before creating instances. 
# Each instances will generate ids to differs between them.

# Configuration are the default Nodes this module provides.
# Node:          [id, name]
# Parameters:    [id, nodeId, name, dtype, slot, category, origin, value]
        
# Dictionay with the info of the instances
GLOBAL_PARAMETERS = {}
GLOBAL_NODES = {}

NODE_INFO =  ["id", "name"]
PARAMETER_INFO =  ["id", "nodeId", "name", "dtype", "slot", "category", "origin", "value"]

def sum (x,y):
    return x + y

def substract (x,y):
    return x - y

def variable (x, dtype = float, broadcastable = None, name = None ):
     return np.asarray(x, dtype = dtype)
   
def constant (x, dtype = None, name = None):
    return x

# This instance will be used to create the instances
def generateUId():
    return uuid.uuid4().get_hex()

class BaseClass (object):
    def __init__(self, *args, **kwargs):
        self.__dict__.update(kwargs)
    def deserialize(self):
        return [value for (key, value) in self.__dict__.items() ]

class Parameter (BaseClass):
    def __init__(self, *args, **kwargs):
        kwargs.update ({PARAMETER_INFO[index] : value  for index, value in enumerate(args)})
        super(Parameter, self).__init__(*args, **kwargs)
    def eval(self):
        if (self.origin is not None):
            if (self.dtype == "function"):
                self.value = self.eval_function(self.origin)
            else:
                origin = GLOBAL_PARAMETERS[self.origin]
                origin.eval()
                self.value = origin.value
    def eval_function (self,strfunc):
        params = strfunc.split(":")[0].replace ("lambda","", 1).strip().split(",")
        inputs = [GLOBAL_PARAMETERS[GLOBAL_NODES[self.nodeId].parameters[param.strip()]] for param in params]
        map(lambda input: input.eval(), inputs) 
        values = [input.value for input in inputs]
        return eval(strfunc)(*values)  
    def deserialize(self):
        return [ self.__dict__[key] for key in PARAMETER_INFO]

class Node (BaseClass):
    def __init__(self, *args, **kwargs):
          kwargs.update ({NODE_INFO[index] : value  for index, value in enumerate(args)})
          super(Node, self).__init__(*args, **kwargs)
          self.parameters  = {value.name : key for key, value in GLOBAL_PARAMETERS.items() if (value.nodeId == self.id)}
    def process(self):
        map (lambda (key, value): GLOBAL_PARAMETERS[value].eval(), self.parameters.items())
    def deserialize(self):
        return [ self.__dict__[key] for key in NODE_INFO]


# The idea is to create some examples and store the instances into nodes to save them and load the later again 

########################
## LINKED NODES GRAPH ##
########################

# Now the tool or the graphic tool will use these templates in order to create instances of them.
# Also these templates could be generated by using assemblies.

templatesDB = {
    "nodes": [
             ["1", "sum"], 
               ["2", "substract"],
               ["3", "variable"],
               ["4", "constant"] 
             ],
    "Parameters" : [
                     ["11", "1", "x", "float", 0, "public", None, 0 ],
                     ["12", "1", "y", "float", 0, "public", None, 0 ],
                     ["13", "1", "output", "function", 1, "public",  "lambda x, y: sum (x,y)", 0 ] ,
                     ["21", "2", "x", "float", 0, "public", None, 0 ],
                     ["22", "2", "y", "float", 0, "public", None, 0 ],
                     ["23", "2", "output", "function", 1, "public", "lambda x, y: substract (x,y)", 0 ],
                     ["24", "2", "shape", "function", 1, "public", "lambda output: output.shape", 0 ],
                     ["31", "3", "input", "float", 0, "public", None, 0 ],
                     ["32", "3", "output", "float", 1, "public", "lambda input: variable (input)", 0 ],
                     ["41", "4", "input", "float", 0, "public", None, 0 ],
                     ["42", "4", "output", "float", 1, "public", "lambda input: constant (input)", 0 ] 
                   ]
    }

# Instances are uses of the Templates already created
# The way the tool will create instances will be adding some extraid in order to differenciate one from another 

instancesDB = {
    "nodes": [ 
               ["I1", "mysum"], 
               ["I2", "mysubstract"],
               ["I3", "variable"],
               ["I4", "constant"]
              ],
    "parameters" : [
                     ["I11", "I1", "x", "float", 0, "public", "I32", 0 ],
                     ["I12", "I1", "y", "float", 0, "public", "I42", 0 ],
                     ["I13", "I1", "output", "function", 1, "public", "lambda x, y: sum (x,y)", 0 ] ,
                     ["I21", "I2", "x", "float", 0, "public", "I13", 0 ],
                     ["I22", "I2", "y", "float", 0, "public", None, 2.6 ],
                     ["I23", "I2", "output", "function", 1, "public", "lambda x, y: substract (x,y)", 0 ],
                     ["I24", "I2", "shape", "function", 1, "public", "lambda output: output.shape", 0 ],
                     ["I31", "I3", "input", "float", 0, "public", None, [0,1,2,3] ],
                     ["I32", "I3", "output", "function", 1, "public", "lambda input: variable (input)", 0 ],
                     ["I41", "I4", "input", "float", 0, "public", None, 4 ],
                     ["I42", "I4", "output", "function", 1, "public", "lambda input: constant (input)", 0 ]
                    ]
    } # Result must be 31


# Create a dict with all parameters and nodes from the data source (DB, files, web reques, etc..)
GLOBAL_PARAMETERS = {param[0] : Parameter(*param) for param in instancesDB["parameters"]}
GLOBAL_NODES = {node[0] : Node(*node) for node in instancesDB["nodes"]}

#####################################
## Deserialzie the objects (again) ##
#####################################

#for key, value in GLOBAL_PARAMETERS.items():
#    print (value.deserialize())
#for key, value in GLOBAL_NODES.items():
#    print (value.deserialize())

# CREATE JSON with the current instances
#json_instances = { "nodes" : [value.deserialize() for key, value in GLOBAL_NODES.items() ],
#                   "parameters" :  [value.deserialize() for key, value in GLOBAL_PARAMETERS.items() ] }

#with open('data.txt', 'w') as outfile:
#    json.dump(json_instances, outfile)

##########################
## LOAD AGAIN FROM JSON ##
##########################

#with open('data.txt', 'r') as infile:
#    instancesDB = json.load(infile)

## Create a dict with all parameters and nodes from the data source (DB, files, web reques, etc..)
#GLOBAL_PARAMETERS = {param[0] : Parameter(*param) for param in instancesDB["parameters"]}
#GLOBAL_NODES = {node[0] : Node(*node) for node in instancesDB["nodes"]}

#######################
## Process the graph ##
#######################

#Nodes["I1"].process()
#Nodes["I2"].process()
#print (Parameters["I13"].value)
#print (Parameters["I23"].value)

# Process the last Node in the graph to propage the evaluation between nodes and parameters
GLOBAL_NODES["I2"].process()

print (GLOBAL_PARAMETERS["I23"].value)
print (GLOBAL_PARAMETERS["I24"].value)

# Also we can visualizxe each output param separately
#print (GLOBAL_PARAMETERS["I13"].value)
#print (GLOBAL_PARAMETERS["I23"].value)
#print (GLOBAL_PARAMETERS["I32"].value)
#print (GLOBAL_PARAMETERS["I42"].value)

# Load and save from MONGODB instead files -> To share between distribuited systems and platforms.

# In this case it would be useful to think in a structure that will be independent for the platform or technology, easy to change or modifiy and flexible.
# DATABASE
#   USERS
#       PROJECTS
#           GRAPHS
#               NODES
#               PARAMETERS
#       CUSTOM
#             GRAPHS
#                NODES
#                PARAMETERS

#   TEMPLATES
#       GRAPHS
#           NODES
#           PARAMETERS

            
        
# ASSEMBLIES are nodes that hacve connection to another nodes.








# Create Nodes that theano use .... by using the framework Singularity (only a simple convolution network)





# Load,save add extranodes, etc..  


print ("END")

